import { tool, type InferUITools, type UIMessage } from "ai";
import z from "zod";

// ============================================
// Custom Data Part Types for User Messages
// ============================================

// User typed a question directly in the input box
export const userInputDataSchema = z.object({
  text: z.string(),
});

// User selected a start option (Walkthrough, Dive In, etc.)
export const startOptionDataSchema = z.object({
  title: z.string(),
  prompt: z.string(),
});

// User clicked a follow-up option generated by generate_options tool
export const followUpOptionDataSchema = z.object({
  label: z.string(),
  value: z.string(),
});

// User asked about selected text in document ("What's this?")
export const askTutorDataSchema = z.object({
  selectedText: z.string(),
  question: z.string(),
});

// User requested help on a response block
export const askHelpDataSchema = z.object({
  question: z.string(),
  currentAnswer: z.string(),
});

// System auto-message after prompt_student answered correctly (should be hidden)
export const promptAnswerDataSchema = z.object({
  answer: z.string(),
  hidden: z.literal(true),
});

// Combined schema for all custom data parts
export const userDataPartsSchema = z.object({
  "user-input": userInputDataSchema,
  "start-option": startOptionDataSchema,
  "follow-up-option": followUpOptionDataSchema,
  "ask-tutor": askTutorDataSchema,
  "ask-help": askHelpDataSchema,
  "prompt-answer": promptAnswerDataSchema,
});

export type UserDataParts = z.infer<typeof userDataPartsSchema>;

// Type helper for creating data parts
export type DataPart<K extends keyof UserDataParts> = {
  type: `data-${K}`;
  data: UserDataParts[K];
};

export const editOperationSchema = z.object({
  search: z.string(),
  replace: z.string(),
});

export type EditOperation = z.infer<typeof editOperationSchema>;

export const optionSchema = z.object({
  label: z.string(),
  value: z.string(),
});

export type Option = z.infer<typeof optionSchema>;

export const choiceOptionSchema = z.object({
  label: z
    .string()
    .describe("The display text for this choice (supports markdown)"),
  value: z.string().describe("The value to submit if this choice is selected"),
});

export type ChoiceOption = z.infer<typeof choiceOptionSchema>;

export const promptStudentSchema = z.object({
  question: z
    .string()
    .describe("The question or prompt to display (supports markdown)"),
  type: z
    .enum(["text", "single-choice", "multiple-choice"])
    .describe(
      "The type of response expected: 'text' for free-form input, 'single-choice' for selecting one option, 'multiple-choice' for selecting multiple options",
    ),
  options: z
    .array(choiceOptionSchema)
    .optional()
    .describe(
      "Required for choice types. Array of options for the student to choose from.",
    ),
  hint: z
    .string()
    .optional()
    .describe("Optional hint to help guide the student's response"),
});

export type PromptStudentInput = z.infer<typeof promptStudentSchema>;

export const tools = {
  edit_document: tool({
    description:
      "Apply edits to the student's document. Call this at an appropriate point during the conversation, like a TA would write while explaining. You can start with brief explanation, then edit the document, then continue explaining.",
    inputSchema: z.object({
      edits: z
        .array(editOperationSchema)
        .describe(
          "Array of search-replace operations. Each edit should include enough context (3-5 words before and after) to uniquely identify the text to replace.",
        ),
      summary: z
        .string()
        .describe(
          "Brief explanation of why you're making these edits (for logging/debugging)",
        ),
    }),
    outputSchema: z.union([
      z.object({
        success: z.literal(true),
        summary: z
          .string()
          .optional()
          .describe(
            "Copy of your input summary for confirmation/logging purposes.",
          ),
      }),
      z.object({
        success: z.literal(false),
        error: z
          .string()
          .optional()
          .describe("Error message if success is false."),
      }),
    ]),
  }),
  generate_options: tool({
    description:
      "Generate follow-up question options for the student. Call this AFTER your explanation is complete to provide interactive follow-up paths.",
    inputSchema: z.object({
      options: z
        .array(optionSchema)
        .min(2)
        .max(4)
        .describe(
          "Array of 2-4 follow-up options. Each should have a concise label (2-5 words) and a complete question value.",
        ),
    }),
    execute: async ({ options }) => {
      return {
        success: true,
        options,
      };
    },
  }),
  prompt_student: tool({
    description:
      "Prompt the student to answer a question to check their understanding. Use this to interactively test comprehension during explanations. The student must answer correctly before the conversation can continue. Supports text input or multiple choice questions.",
    inputSchema: promptStudentSchema,
    outputSchema: z.object({
      success: z
        .boolean()
        .describe("Whether the student has answered correctly"),
      answer: z
        .string()
        .optional()
        .describe("The student's answer (filled in by the UI)"),
      dismissed: z
        .boolean()
        .optional()
        .describe("Whether the student dismissed the prompt"),
    }),
  }),
};

export type TutorMessage = UIMessage<
  never,
  UserDataParts,
  InferUITools<typeof tools>
>;
